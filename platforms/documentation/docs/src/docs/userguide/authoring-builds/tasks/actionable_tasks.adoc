// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[actionable_tasks]]
= Actionable Tasks

Actionable tasks have inputs and outputs.
Inputs and outputs can be files, directories, or properties.

Actionable tasks describe work in Gradle.

In Gradle core, the `compileJava` task compiles the Java source code.
The `Jar` and `Zip` tasks zip up files into archives.

Let's look into registering and configuring actionable tasks.

[[sec:task_groups]]
== Task inputs and outputs

In actionable tasks:

- *Inputs* consist of a collection of files, folders, and/or configuration data. +
For instance, the `javaCompile`takes inputs such as Java source files and build script configurations like the Java version.
- *Outputs* refer to one or multiple files or folders. +
For instance, the `javaCompile` produces class files as output.

Furthermore, the `jar` task takes these class files as input and produces a JAR archive.

Clearly defined task inputs and outputs serve two purposes:

1. They inform Gradle about task dependencies. +
For example, if Gradle understands that the output of the `compileJava` task serves as the input for the `jar` task, it will prioritize running `compileJava` first.
2. They facilitate incremental building. +
For example, if Gradle recognizes that the inputs and outputs of a task remain unchanged, it can leverage results from previous build runs or the build cache, thereby avoiding the need to rerun the task action altogether.

When you apply a plugin like the `java-library` plugin.
Gradle will automatically register some tasks and configure them with defaults.

Let's define a task that packages JARs and a start script into an archive in an imaginary sample project:

====
[.multi-language-sample]
=====
[source,kotlin]
----
gradle-project
├── app
│   ├── build.gradle.kts    // app build logic
│   ├── run.sh              // script file
│   └── ...                 // some java code
├── settings.gradle.kts     // includes app subproject
├── gradle
├── gradlew
└── gradlew.bat
----
=====
[.multi-language-sample]
=====
[source,groovy]
----
gradle-project
├── app
│   ├── build.gradle    // app build logic
│   ├── run.sh          // script file
│   └── ...             // some java code
├── settings.gradle     // includes app subproject
├── gradle
├── gradlew
└── gradlew.bat
----
=====
====

The `run.sh` script can execute the java app (once packaged as a JAR) from the build:

.app/run.sh
[source,bash]
----
java -cp 'libs/*' gradle.project.App
----

Let's register a new task called `packageApp` using `task.register()`:

====
[.multi-language-sample]
=====
.app/build.gradle.kts
[source,kotlin]
----
tasks.register<Zip>("packageApp") {

}
----
=====
[.multi-language-sample]
=====
.app/build.gradle
[source,groovy]
----
tasks.register(Zip, "packageApp") {

}
----
=====
====

We used an existing implementation from Gradle core which is the `Zip` task implementation (i.e,. a subclass of `Task`).
Because we register a new task here, it's not pre-configured so we need to configure the inputs and outputs.

Defining inputs and outputs is essentially what makes a task an actionable task.

For the `Zip` task type, we can use the `from` notation to add a file to the inputs.
In our case, we add the run script.

If the input is a file we create or edit directly, like a run file or Java source code, it's usually located somewhere in our project directory.
To ensure we use the correct location, we use `layout.projectDirectory` and define a relative path to the project directory root.

We provide the outputs of the `jar` task as well as the JAR of all the dependencies (using `configurations.runtimeClasspath`) as additional inputs.

For outputs, we need to define two properties.
First, the destination directory, which should be a directory inside the build folder.
We can access this through `layout`.
Second, we need to specify a name for the zip file, which we've called `myapplication.zip`

Here is what the complete task looks like:

====
[.multi-language-sample]
=====
.app/build.gradle.kts
[source,kotlin]
----
val packageApp = tasks.register<Zip>("packageApp") {
    from(layout.projectDirectory.file("run.sh"))                // input - run.sh file
    from(tasks.jar) {                                           // input - jar task output
        into("libs")
    }
    from(configurations.runtimeClasspath) {                     // input - jar of dependencies
        into("libs")
    }
    destinationDirectory.set(layout.buildDirectory.dir("dist")) // output - location of the zip file
    archiveFileName.set("myApplication.zip")                    // output - name of the zip file
}
----
=====
[.multi-language-sample]
=====
.app/build.gradle
[source,groovy]
----
def packageApp = tasks.register(Zip, 'packageApp') {
    from layout.projectDirectory.file('run.sh')                 // input - run.sh file
    from tasks.jar {                                            // input - jar task output
        into 'libs'
    }
    from configurations.runtimeClasspath {                      // input - jar of dependencies
        into 'libs'
    }
    destinationDirectory.set(layout.buildDirectory.dir('dist')) // output - location of the zip file
    archiveFileName.set('myApplication.zip')                    // output - name of the zip file
}
----
=====
====

if we run our `packageApp` task, `myApplication.zip` is produced:

[source,text]
----
$./gradlew :app:packageApp

> Task :app:compileJava
> Task :app:processResources NO-SOURCE
> Task :app:classes
> Task :app:jar
> Task :app:packageApp

BUILD SUCCESSFUL in 1s
3 actionable tasks: 3 executed
----

Gradle executed a number of tasks it required to build the JAR file, which is in addition to the JAR itself includes the compilation of the code of the `app` project and the compilation of code dependencies.

Looking at the newly created ZIP file, we can see that it contains everything needed to run the Java application:

[source,bash]
----
> unzip -l ./app/build/dist/myApplication.zip

Archive:  ./app/build/dist/myApplication.zip
  Length      Date    Time    Name
---------  ---------- -----   ----
       42  01-31-2024 14:16   run.sh
        0  01-31-2024 14:22   libs/
      847  01-31-2024 14:22   libs/app.jar
  3041591  01-29-2024 14:20   libs/guava-32.1.2-jre.jar
     4617  01-29-2024 14:15   libs/failureaccess-1.0.1.jar
     2199  01-29-2024 14:15   libs/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar
    19936  01-29-2024 14:15   libs/jsr305-3.0.2.jar
   223979  01-31-2024 14:16   libs/checker-qual-3.33.0.jar
    16017  01-31-2024 14:16   libs/error_prone_annotations-2.18.0.jar
---------                     -------
  3309228                     9 files
----

Actionable tasks should be wired to lifecycle tasks so that a developer only need run lifecycle tasks.

So far we called our new task directly.
Let's wire it to a lifecycle task.

The following is added to the build script so that the `packageApp` actionable task is wired to the `build` lifecycle task using `dependsOn()`:

====
[.multi-language-sample]
=====
.app/build.gradle.kts
[source,kotlin]
----
tasks.build {
    dependsOn(packageApp)
}
----
=====
[.multi-language-sample]
=====
.app/build.gradle
[source,groovy]
----
tasks.build {
    dependsOn(packageApp)
}
----
=====
====

You could  define your own lifecycle task if needed.
