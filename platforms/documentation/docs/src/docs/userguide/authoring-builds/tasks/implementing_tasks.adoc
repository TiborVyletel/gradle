// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[implementing_tasks]]
= Implementing Tasks

To address more individual needs and if no existing plugins provide the build functionality you need, you can create your own task implementation.

== Extending `DefaultTask`

Let's start with an example built by Gradle `init` for a Java application with multiple subprojects:

====
[.multi-language-sample]
=====
[source,kotlin]
----
gradle-project
├── app
│   ├── build.gradle.kts
│   └── src                 // some java code
│       └── ...
├── utilities
│   ├── build.gradle.kts
│   └── src                 // some java code
│       └── ...
├── list
│   ├── build.gradle.kts
│   └── src                 // some java code
│       └── ...
├── buildSrc
│   ├── build.gradle.kts
│   ├── settings.gradle.kts
│   └── src                 // common build logic
│       └── ...
├── settings.gradle.kts
├── gradle
├── gradlew
└── gradlew.bat
----
=====
[.multi-language-sample]
=====
[source,groovy]
----
gradle-project
├── app
│   ├── build.gradle
│   └── src             // some java code
│       └── ...
├── utilities
│   ├── build.gradle
│   └── src             // some java code
│       └── ...
├── list
│   ├── build.gradle
│   └── src             // some java code
│       └── ...
├── buildSrc
│   ├── build.gradle
│   ├── settings.gradle
│   └── src             // common build logic
│       └── ...
├── settings.gradle
├── gradle
├── gradlew
└── gradlew.bat
----
=====
====

If we look into the script, we see that it contains information that could be configured in the build script, such as the name of the main class.
So now, instead of adding the start script as a file directly, we would like Gradle to generate it and configure the main class name in the build script.

As mentioned before, it's convenient that our convention plugin scripts are inside the Kotlin source folder.
Now we can add more source code to this folder and keep all the build logic well-structured.

We add a new Kotlin class to implement our task.
To let Gradle know that this is a task implementation, we have to extend the `DefaultTask` class that comes with Gradle.
It's also beneficial to make our task class `abstract` because Gradle will handle many things automatically:

[source,kotlin]
----
Abstract class GenerateStartScript : DefaultTask() {

}
----

Next, we define the inputs and outputs using properties and annotations. In this context, properties in Gradle act as references to the actual values behind them, allowing Gradle to track inputs and outputs between tasks.

For the input of our task, we define an abstract Kotlin property using the property interface of Gradle.
We annotate it with `@Input` to indicate that it is an input to the task.

[source,kotlin]
----
Abstract class GenerateStartScript : DefaultTask() {
    @get :Input
    abstract val mainClass: Property<String>
}
----

Similarly, for the output, we use a `RegularFileProperty` and annotate it with `@OutputFile`.

[source,kotlin]
----
Abstract class GenerateStartScript : DefaultTask() {
    @get :Input
    abstract val mainClass: Property<String>

	@get: OutputFile
	abstract val scriptFile: RegularFileProperty
}
----

With inputs and outputs defined, the only thing that remains is the actual task action, which is implemented in a method annotated with `@TaskAction`.
Inside this method, we write normal Kotlin code with minimal Gradle-specific details, mainly accessing inputs and outputs using Gradle-specific APIs:

[source,kotlin]
----
Abstract class GenerateStartScript : DefaultTask() {
    @get :Input
    abstract val mainClass: Property<String>

	@get: OutputFile
	abstract val scriptFile: RegularFileProperty

	@TaskAction
	fun generate() {
		val main = mainClass.get()
		val out = scriptFile.get().asFile
		var script = “”

		out.writeText(script)
    }
}
----

The task generates the content of the script file, writes it to the output file, and adjusts file permissions.

Now, back in our application convention plugin, we can register this task using `task.register()`.

Finally, we configure the inputs and outputs of the Zip task to use the output of our custom start script generation task.
The main class for the start script task is configured in the build script:

[source,kotlin]
----
Val geberateSrtartScript = task.register<GenerateStartScript>(“geberateStartScrip”) {}

Val packageApp = tasks.register<Zip> …. {
From(generateStartScript)
…
}

Tasks.generateStartScript {
mainclass.set(“vfdgdgfd”)
}

Interface MyAppExtension {
val mainClass: Property<String>
}


Val generateStartScript = tasks.register<>(“) {
mainClass.convention(….)
….
}
----

By running the build, we observe that our start script generation task is executed, and it's up to date in subsequent builds. Gradle's incremental building and caching mechanisms work seamlessly with custom tasks:

[source,text]
----
./gradlew :app:build
----

This demonstrates the power of Gradle in handling complex build logic, ensuring efficiency when defining inputs and outputs correctly. More details on configuring inputs and outputs for optimal task cachability are available in the linked GitHub page.

As a final note, although we directly configured tasks in the build script (contrary to the earlier rule of using extensions), we explored how easy it is to define and use custom extensions for configuration. This ensures adherence to best practices in Gradle build scripts.
