// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[actionable_tasks]]
= Actionable Tasks

Actionable tasks describe work in Gradle.
These tasks have actions.

In Gradle core, the `compileJava` task compiles the Java source code.
The `Jar` and `Zip` tasks zip up files into archives.

[[sec:task_groups]]
== Task inputs and outputs

Actionable tasks have inputs and outputs.
Inputs and outputs can be files, directories, or variables.

In actionable tasks:

- *Inputs* consist of a collection of files, folders, and/or configuration data. +
For instance, the `javaCompile` task takes inputs such as Java source files and build script configurations like the Java version.
- *Outputs* refer to one or multiple files or folders. +
For instance, the `javaCompile` produces class files as output.

Then, the `jar` task takes these class files as input and produces a JAR archive.

Clearly defined task inputs and outputs serve two purposes:

1. They inform Gradle about task dependencies. +
For example, if Gradle understands that the output of the `compileJava` task serves as the input for the `jar` task, it will prioritize running `compileJava` first.
2. They facilitate incremental building. +
For example, if Gradle recognizes that the inputs and outputs of a task remain unchanged, it can leverage results from previous build runs or the build cache, thereby avoiding the need to rerun the task action altogether.

When you apply a plugin like the `java-library` plugin.
Gradle will automatically register some tasks and configure them with defaults.

Let's define a task that packages JARs and a start script into an archive in an imaginary sample project:

====
[.multi-language-sample]
=====
[source,kotlin]
----
gradle-project
├── app
│   ├── build.gradle.kts    // app build logic
│   ├── run.sh              // script file
│   └── ...                 // some java code
├── settings.gradle.kts     // includes app subproject
├── gradle
├── gradlew
└── gradlew.bat
----
=====
[.multi-language-sample]
=====
[source,groovy]
----
gradle-project
├── app
│   ├── build.gradle    // app build logic
│   ├── run.sh          // script file
│   └── ...             // some java code
├── settings.gradle     // includes app subproject
├── gradle
├── gradlew
└── gradlew.bat
----
=====
====

The `run.sh` script can execute the Java app (once packaged as a JAR) from the build:

.app/run.sh
[source,bash]
----
java -cp 'libs/*' gradle.project.app.App
----

Let's register a new task called `packageApp` using link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#register-java.lang.String-java.lang.Class-[`task.register()`]:

====
[.multi-language-sample]
=====
.app/build.gradle.kts
[source,kotlin]
----
tasks.register<Zip>("packageApp") {

}
----
=====
[.multi-language-sample]
=====
.app/build.gradle
[source,groovy]
----
tasks.register(Zip, "packageApp") {

}
----
=====
====

We used an existing implementation from Gradle core which is the link:{javadocPath}/org/gradle/api/tasks/bundling/Zip.html[`Zip`] task implementation (i.e., a subclass of link:{javadocPath}/org/gradle/api/DefaultTask.html[`DefaultTask`]).
Because we register a new task here, it's not pre-configured.
We need to configure the inputs and outputs.

Defining inputs and outputs is essentially what makes a task an actionable task.

For the link:{javadocPath}/org/gradle/api/tasks/bundling/Zip.html[`Zip`] task type, we can use the link:{javadocPath}/org/gradle/api/tasks/AbstractCopyTask.html#from-java.lang.Object...-[`from()`] method to add a file to the inputs.
In our case, we add the run script.

If the input is a file we create or edit directly, like a run file or Java source code, it's usually located somewhere in our project directory.
To ensure we use the correct location, we use link:{javadocPath}/org/gradle/api/file/ProjectLayout.html#getProjectDirectory--[`layout.projectDirectory`] and define a relative path to the project directory root.

We provide the outputs of the `jar` task as well as the JAR of all the dependencies (using link:{javadocPath}/org/gradle/api/Project.html#getConfigurations--[`configurations`]link:{javadocPath}/org/gradle/api/tasks/SourceSet.html#getRuntimeClasspath--[`.runtimeClasspath`]) as additional inputs.

For outputs, we need to define two properties.
First, the destination directory, which should be a directory inside the build folder.
We can access this through link:{javadocPath}/org/gradle/api/file/ProjectLayout.html[`layout`].
Second, we need to specify a name for the zip file, which we've called `myApplication.zip`

Here is what the complete task looks like:

====
[.multi-language-sample]
=====
.app/build.gradle.kts
[source,kotlin]
----
val packageApp = tasks.register<Zip>("packageApp") {
    from(layout.projectDirectory.file("run.sh"))                // input - run.sh file
    from(tasks.jar) {                                           // input - jar task output
        into("libs")
    }
    from(configurations.runtimeClasspath) {                     // input - jar of dependencies
        into("libs")
    }
    destinationDirectory.set(layout.buildDirectory.dir("dist")) // output - location of the zip file
    archiveFileName.set("myApplication.zip")                    // output - name of the zip file
}
----
=====
[.multi-language-sample]
=====
.app/build.gradle
[source,groovy]
----
def packageApp = tasks.register(Zip, 'packageApp') {
    from layout.projectDirectory.file('run.sh')                 // input - run.sh file
    from tasks.jar {                                            // input - jar task output
        into 'libs'
    }
    from configurations.runtimeClasspath {                      // input - jar of dependencies
        into 'libs'
    }
    destinationDirectory.set(layout.buildDirectory.dir('dist')) // output - location of the zip file
    archiveFileName.set('myApplication.zip')                    // output - name of the zip file
}
----
=====
====

if we run our `packageApp` task, `myApplication.zip` is produced:

[source,text]
----
$./gradlew :app:packageApp

> Task :app:compileJava
> Task :app:processResources NO-SOURCE
> Task :app:classes
> Task :app:jar
> Task :app:packageApp

BUILD SUCCESSFUL in 1s
3 actionable tasks: 3 executed
----

Gradle executed a number of tasks it required to build the JAR file, which includes the compilation of the code of the `app` project and the compilation of code dependencies.

Looking at the newly created ZIP file, we can see that it contains everything needed to run the Java application:

[source,bash]
----
> unzip -l ./app/build/dist/myApplication.zip

Archive:  ./app/build/dist/myApplication.zip
  Length      Date    Time    Name
---------  ---------- -----   ----
       42  01-31-2024 14:16   run.sh
        0  01-31-2024 14:22   libs/
      847  01-31-2024 14:22   libs/app.jar
  3041591  01-29-2024 14:20   libs/guava-32.1.2-jre.jar
     4617  01-29-2024 14:15   libs/failureaccess-1.0.1.jar
     2199  01-29-2024 14:15   libs/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar
    19936  01-29-2024 14:15   libs/jsr305-3.0.2.jar
   223979  01-31-2024 14:16   libs/checker-qual-3.33.0.jar
    16017  01-31-2024 14:16   libs/error_prone_annotations-2.18.0.jar
---------                     -------
  3309228                     9 files
----

Actionable tasks should be wired to lifecycle tasks so that a developer only need run lifecycle tasks.

So far we called our new task directly.
Let's wire it to a lifecycle task.

The following is added to the build script so that the `packageApp` actionable task is wired to the `build` lifecycle task using link:{javadocPath}/org/gradle/api/DefaultTask.html#dependsOn-java.lang.Object...-[`dependsOn()`]:

====
[.multi-language-sample]
=====
.app/build.gradle.kts
[source,kotlin]
----
tasks.build {
    dependsOn(packageApp)
}
----
=====
[.multi-language-sample]
=====
.app/build.gradle
[source,groovy]
----
tasks.build {
    dependsOn(packageApp)
}
----
=====
====

We see that running `:build` also runs `:packageApp`:

[source,text]
----
$ ./gradlew :app:build

> Task :app:compileJava UP-TO-DATE
> Task :app:processResources NO-SOURCE
> Task :app:classes UP-TO-DATE
> Task :app:jar UP-TO-DATE
> Task :app:startScripts
> Task :app:distTar
> Task :app:distZip
> Task :app:assemble
> Task :app:compileTestJava
> Task :app:processTestResources NO-SOURCE
> Task :app:testClasses
> Task :app:test
> Task :app:check
> Task :app:packageApp
> Task :app:build

BUILD SUCCESSFUL in 1s
8 actionable tasks: 6 executed, 2 up-to-date
----

You could define your own lifecycle task if needed.

== Task implementation by extending `DefaultTask`

To address more individual needs and if no existing plugins provide the build functionality you need, you can create your own task implementation.

Creating a custom task implementation means creating a custom class type which is done by subclassing link:{javadocPath}/org/gradle/api/DefaultTask.html[`DefaultTask`]

Let's start with an example built by Gradle `init` for a simple Java application with the source code in the `app` subproject and the build logic in the `buildSrc`:

====
[.multi-language-sample]
=====
[source,kotlin]
----
gradle-project
├── app
│   ├── build.gradle.kts
│   └── src                 // some java code
│       └── ...
├── buildSrc
│   ├── build.gradle.kts
│   ├── settings.gradle.kts
│   └── src                 // common build logic
│       └── ...
├── settings.gradle.kts
├── gradle
├── gradlew
└── gradlew.bat
----
=====
[.multi-language-sample]
=====
[source,groovy]
----
gradle-project
├── app
│   ├── build.gradle
│   └── src             // some java code
│       └── ...
├── buildSrc
│   ├── build.gradle
│   ├── settings.gradle
│   └── src             // common build logic
│       └── ...
├── settings.gradle
├── gradle
├── gradlew
└── gradlew.bat
----
=====
====

We add a new Kotlin class to implement our task called `GenerateReportTask` in `./buildSrc/src/main/kotlin/GenerateReportTask.kt` or `./buildSrc/src/main/groovy/GenerateReportTask.groovy`.

To let Gradle know that this is a task implementation, we have to extend the `DefaultTask` class that comes with Gradle.
It's also beneficial to make our task class `abstract` because Gradle will handle many things automatically:

====
[.multi-language-sample]
=====
.buildSrc/src/main/kotlin/GenerateReportTask.kt
[source,kotlin]
----
import org.gradle.api.DefaultTask

public abstract class GenerateReportTask : DefaultTask() {

}
----
=====
[.multi-language-sample]
=====
.buildSrc/src/main/groovy/GenerateReportTask.groovy
[source,groovy]
----
import org.gradle.api.DefaultTask

public abstract class GenerateReportTask extends DefaultTask {

}
----
=====
====

Next, we define the inputs and outputs using properties and annotations.
In this context, properties in Gradle act as references to the actual values behind them, allowing Gradle to track inputs and outputs between tasks.

For the input of our task, we use a `DirectoryProperty` from Gradle.
We annotate it with `@InputDirectory` to indicate that it is an input to the task.
The @get annotation is used to annotate the property's getter method.

====
[.multi-language-sample]
=====
.buildSrc/src/main/kotlin/GenerateReportTask.kt
[source,kotlin]
----
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.InputDirectory

public abstract class GenerateReportTask : DefaultTask() {

    @get:InputDirectory
    lateinit var sourceDirectory: File

    @get:OutputFile
    lateinit var reportFile: File

}
----
=====
[.multi-language-sample]
=====
.buildSrc/src/main/groovy/GenerateReportTask.groovy
[source,groovy]
----
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.InputDirectory

public abstract class GenerateReportTask extends DefaultTask {

    @InputDirectory
    File sourceDirectory

}
----
=====
====

Similarly, for the output, we use a `RegularFileProperty` and annotate it with `@OutputFile`.

====
[.multi-language-sample]
=====
.buildSrc/src/main/kotlin/GenerateReportTask.kt
[source,kotlin]
----
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.InputDirectory
import org.gradle.api.tasks.OutputFile

public abstract class GenerateReportTask : DefaultTask() {

    @get:InputDirectory
    lateinit var sourceDirectory: File

    @get:OutputFile
    lateinit var reportFile: File

}
----
=====
[.multi-language-sample]
=====
.buildSrc/src/main/groovy/GenerateReportTask.groovy
[source,groovy]
----
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.InputDirectory
import org.gradle.api.tasks.OutputFile

public abstract class GenerateReportTask extends DefaultTask {

    @InputDirectory
    File sourceDirectory

    @OutputFile
    File reportFile

}
----
=====
====

With inputs and outputs defined, the only thing that remains is the actual task action, which is implemented in a method annotated with `@TaskAction`.
Inside this method, we write normal Kotlin code with minimal Gradle-specific details, mainly accessing inputs and outputs using Gradle-specific APIs:

====
[.multi-language-sample]
=====
.buildSrc/src/main/kotlin/GenerateReportTask.kt
[source,kotlin]
----
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.InputDirectory
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.TaskAction

public abstract class GenerateReportTask : DefaultTask() {

    @get:InputDirectory
    lateinit var sourceDirectory: File

    @get:OutputFile
    lateinit var reportFile: File

    @TaskAction
    fun generateReport() {
        val fileCount = sourceDirectory.listFiles().count { it.isFile }
        val directoryCount = sourceDirectory.listFiles().count { it.isDirectory }

        val reportContent = """
            |Report for directory: ${sourceDirectory.absolutePath}
            |------------------------------
            |Number of files: $fileCount
            |Number of subdirectories: $directoryCount
        """.trimMargin()

        reportFile.writeText(reportContent)
        println("Report generated at: ${reportFile.absolutePath}")
    }
}
----
=====
[.multi-language-sample]
=====
.buildSrc/src/main/groovy/GenerateReportTask.groovy
[source,groovy]
----
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.InputDirectory
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.TaskAction

public abstract class GenerateReportTask extends DefaultTask {

    @InputDirectory
    File sourceDirectory

    @OutputFile
    File reportFile

    @TaskAction
    void generateReport() {
        def fileCount = sourceDirectory.listFiles().count { it.isFile() }
        def directoryCount = sourceDirectory.listFiles().count { it.isDirectory() }

        def reportContent = """
            Report for directory: ${sourceDirectory.absolutePath}
            ------------------------------
            Number of files: $fileCount
            Number of subdirectories: $directoryCount
        """.trim()

        reportFile.text = reportContent
        println("Report generated at: ${reportFile.absolutePath}")
    }
}
----
=====
====

The task generates a report of the files contained in the `sourceDirectory`.

Now, back in our application build file, we can register this task using `task.register()`.

Finally, we configure the inputs and outputs of the task:

====
[.multi-language-sample]
=====
.app/build.gradle.kts
[source,kotlin]
----
tasks.register<GenerateReportTask>("generateReport") {
    sourceDirectory = file("src/main")
    reportFile = file("${layout.buildDirectory}/reports/directoryReport.txt")
}

tasks.build {
    dependsOn("generateReport")
}
----
=====
[.multi-language-sample]
=====
.app/build.gradle
[source,groovy]
----
import org.gradle.api.tasks.Copy

tasks.register(GenerateReportTask, "generateReport") {
sourceDirectory = file("src/main")
reportFile = file("${layout.buildDirectory}/reports/directoryReport.txt")
}

tasks.build.dependsOn("generateReport")
----
=====
====

By running the build, we observe that our start script generation task is executed, and it's up to date in subsequent builds. Gradle's incremental building and caching mechanisms work seamlessly with custom tasks:

[source,text]
----
./gradlew :app:build
----

This demonstrates the power of Gradle in handling complex build logic, ensuring efficiency when defining inputs and outputs correctly. More details on configuring inputs and outputs for optimal task cachability are available in the linked GitHub page.

[source, text]
----
> Task :buildSrc:checkKotlinGradlePluginConfigurationErrors
> Task :buildSrc:compileKotlin UP-TO-DATE
> Task :buildSrc:compileJava NO-SOURCE
> Task :buildSrc:compileGroovy NO-SOURCE
> Task :buildSrc:pluginDescriptors UP-TO-DATE
> Task :buildSrc:processResources NO-SOURCE
> Task :buildSrc:classes UP-TO-DATE
> Task :buildSrc:jar UP-TO-DATE
> Task :app:compileJava
> Task :app:processResources NO-SOURCE
> Task :app:classes
> Task :app:jar
> Task :app:startScripts
> Task :app:distTar
> Task :app:distZip
> Task :app:assemble
> Task :app:compileTestJava
> Task :app:processTestResources NO-SOURCE
> Task :app:testClasses
> Task :app:test
> Task :app:check

> Task :app:generateReport
Report generated at: ./app/build/reports/directoryReport.txt

> Task :app:packageApp
> Task :app:build

BUILD SUCCESSFUL in 1s
13 actionable tasks: 10 executed, 3 up-to-date
----

As a final note, although we directly configured tasks in the build script (contrary to the earlier rule of using extensions), we explored how easy it is to define and use custom extensions for configuration. This ensures adherence to best practices in Gradle build scripts.

== Task Actions

A task action is the code that implements what a task is doing.

For example, the `javaCompile` task implementation, which is part of Gradle core, calls the Java compiler to transform source code into byte code in its task action.

You can dynamically modify task actions for tasks that are already registered.

Let's look at an example of a simple Gradle build with one `app` subproject that makes up a Java application – containing one Java class and using Gradle's 'application' plugin.
The project has common build logic in the `buildSrc` folder.

We define a task called `printVersion` in the build file of the `app`:

[source,kotlin]
.buildSrc/
----
import org.gradle.api.DefaultTask
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.TaskAction

abstract class PrintVersion : DefaultTask() {

    @get:Input
    abstract val version: Property<String>

    @TaskAction
    fun print() {
        println("Version: ${version.get()}")
    }
}
----

This task does one simple thing, it prints out the version of the project to the command line.

The class extends `DefaultTask`, as all task implementations do, and it has one @Input which is of type Property.
Tt has one method that is annotated with @TaskAction, which prints out the version.

Here it is good to remember that there is a distinction between "configuration code" and "execution code".

The configuration code is executed during Gradle's configuration phase and builds up the model of your project in memory.
So that Gradle knows what it needs to do and what it does not need to do for a certain build invocation.

Everything around the task actions, like the input or output properties, are part of this configuration code.

Only the code inside the task action method is the execution code that does the actual work.
It accesses the inputs and  outputs to do some work if the task is part of the task graph and if it can't be skipped, because it's UP-TO-DATE or it's taken FROM-CACHE.

Now once we have this task implementation, we can use it in our build setup.

So if we go to our convention plugin, we can register a new task there that uses our task implementation.

task.register<PrintVersion>(“printversion”) {
}

Inside the configuration block for the task, we now write configuration  phase code which only modifies the values of input and output properties of the task, but does not touch the execution phase code.

So the task action is not referred here in any way.

It's something Gradle will pick up automatically if needed.
Even for simple custom task implementations like this one, I prefer the setup because it makes a quite clean separation between "configuration time code" and "execution time code".

However, you could write tasks, especially simple tasks like this one, in a bit more compact way directly
in the build script. Without creating a separate class for the task.

Let's register another task and call it 'printVersionDynamic'.

This time, we do not define a type for the task which means the task will be of the general type DefaultTask.

This general type does not define any task actions – that means it does not have methods annotated with @TaskAction.

This type is useful for defining 'lifecycle tasks', which we looked at in the corresponding episode.

But the default task type can also be used to define tasks with custom actions dynamically without additional classes.
This is done by using the doFirst {} or doLast {} construct.

Similar to defining a method and annotating this @TaskAction, this adds an action to this task.
The methods are called doFirst {} and doLast {}, because the task can have multiple actions.

And if the task already has an action defined you can use this distinction to decide if your
additional action should run before or after the existing actions.

tas.register(“printVersionDynamic”) {
doFirst {
// Task action / execution time code
}
doLast {
// Task action / execution time code
}
}

We'll get back to that in a bit.

If you only have one action, which is the case here because we start with an empty task, we typically use the doLast {} method.

Now we can add the action code inside this method.
So we put our println() statement here.

tas.register(“printVersionDynamic”) {
doLast {
print
}
}

Because we are in the build script here, and have the whole project context, we could access the project version now here in the action code directly – without declaring any inputs or something like that.

This used to work, but what you do here is mixing the "configuration time state" and the "execution time state".

Because, remember, that the code here in the doLast {} action block is "execution time code" compared to all the other code in the build script, which is "configuration time code".

If we activate the Gradle Configuration Cache, which you can do since Gradle 8.3 with the 'org.gradle.configuration-cache' property in your 'gradle.properties' file, the task implementation we just performed does not work.
Gradle gives you an error when you attempt to run it.
This is, because the Configuration Cache requires a clean separation between this "configuration time state", which is put into the cache, and the "execution time state".

We can fix this in our example by doing the same we did when  we implemented the printVersionTask as class:
We can declare the version we want to print as an input.

task.register(“printVersionDynamic”) {
inputs.property(“version”, project.version) // add input property dynamically
doLast {
print. //retrieve input property
}
}

This can also be done dynamically. So instead of declaring a property and annotating it with @Input, as we have done in the class-based solution, we can use the general inputs properties that all tasks have.
To add a new input property here dynamically. We give this property some name – let's also call it 'version' here – and then we can retrieve the value of the property in the task action.
And now the task works exactly as it worked when we implemented it as class.

So what we see here are two alternative approaches to implement a custom task in Gradle.

The dynamic setup makes it a bit more compact.
However, as I showed, it's easier to mix configuration time and execution time state here.
It also can get hard to keep an overview, if you need more inputs for a more complex task implementation.
And then you see that this general 'inputs' field here is untyped.
So you have a map with string keys to arbitrary objects. So when you get things out of the map again, in the task action, you need to know which type they are of and possibly cast them.

When you implement your custom task as class, you can clearly Define the inputs as properties with a dedicated type.

We now saw how to use the API for adding task actions dynamically to define your own tasks.
Which is nothing new, but only an alternative to defining your custom tasks as classes.

Where this dynamic modification of actions actually can give additional value, is when you have tasks that are already registered, but which you need to modify for some reason.

Let's take as an example the compileJava task, which is registered by the Java plugins.

Once the task is registered, you can't remove it. It's also difficult, and in certain cases impossible, to remove certain task dependencies that have been set up already by the plugins you are using.

If you combine several community plugins in your build you can have situations where things are not completely compatible or sometimes there might be bugs or unforeseen usages of a plugin in your build that leads to them almost working, but some little details don't fit.

Here the ability to add or modify task actions of tasks that have already been set up by a plugin, can help you to patch
things up.

Let's first add an additional task action to the compileJava task.

task.compuleJava {
doLast {
}
}

The original task, through its implementation in the JavaCompile class, has only one action, which is calling the Java compiler with all the inputs the task is configured with.

Let's say we want to do something before and after the compilation.

For demonstration purpose let's just print out some statements.
For this, we can now use the doFirst {} and the doLast {} methods.

task.compuleJava {
doFirst {
print(actions.size)
}
doLast {
print(inputs.sourceFiles.asPath)
}
}


Note that also in this custom code you add, you can access the inputs and outputs of the task.
Because that's the state that is available at execution time that the original task action also uses.

When we run the build, we see how our additional task actions are executed as part of the compileJava task.

./gradlew compileJava

When we run the build again, and the task is UP-TO-DATE, also our custom actions are not executed.

./gradlew compileJava

So they're really an extension of the actionable code of the existing task.

What I just showed can already be useful if you want to investigate certain situations or problems over a longer time or on CI builds.

You can use doFirst {} or doLast {} to do additional logging for tasks that are already registered.

You could also patch up certain things.
For example, if a task produces files, but the output properties of the task do not allow you to change the file names, you could rename the result files in the doLast {} action.

Remember, for Gradle all the actions make up the execution block.
So Gradle will only look at the result of the task, to calculate the output for up-to-date checks and so on, in the end, when all task actions have been executed

If this is not enough to patch things up, you can actually also modify the existing actions.

This 'actions' list each task has is mutable.
So you can change it in the task configuration.

For example, if a task has, for some reason, multiple actions already, you could change the order.
Or you could remove existing actions.

So here we could say: clear the actions list in the beginning of the compileJava task configuration, which will remove the original Java compile action – even though it has not been added dynamically, but is a method implemented in the JavaCompile class.

task.compuleJava {
actions.clear() // remove compile action from javacompile task
doFirst {
print(actions.size)
}
doLast {
print(inputs.sourceFiles.asPath)
}
}


If we do this and run our build, the compiled class of our application is missing – even though the compileJava task was executed.
Because now, the original task action is no longer part of the build.

Now assuming, for the sake of this example, that the original compilation does not work for us, we can say we implement the compilation ourselves in the actions we add.
For example, in our doLast {} action, we can call the 'javac' command with the input files and the output directory configured for this task.
And now our build works again and we were able to do that without rewiring any task setup or dependencies.

So we keep the existing task structure but do adjustment to the actual action of a task. Of course, in this case, this is not
a complete implementation.
The task has much more inputs, for example, that are passed as parameters to the Java compiler.
For a bit simpler tasks, maybe from community plugins, that do not completely fit your current setup, this can be a last resort to get around blockers.
Of course, in these cases, it might be good to report back to the authors of the plugin to make things more configurable that you don't need to resort to this way of modifying existing task implementations.
